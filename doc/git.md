# Using Git

For the benefit of people who work on this codebase in the future, it's
helpful if Git commits tell a story about _what_ was changed and _why_.

## Background

These articles explain the motivations in more detail and give practical
explanations.

- [Working with Git](https://gds-way.digital.cabinet-office.gov.uk/standards/source-code/working-with-git.html)
  from the GDS blog
- [How to raise a good pull request](https://www.annashipman.co.uk/jfdi/good-pull-requests.html#make-the-pull-request-tell-a-story)
  by Anna Shipman
- [Telling stories with your Git history](https://www.futurelearn.com/info/blog/telling-stories-with-your-git-history)
  by Seb Jacobs for FutureLearn

## Principles

1.  [Make atomic commits](#make-atomic-commits)
2.  [Use the commit message to explain the change](#use-the-commit-message-to-explain-the-change)
3.  [Revise history to tell a logical story](#revise-history-to-tell-a-logical-story)
4.  [Rebase and merge pull requests](#rebase-and-merge-pull-requests)
5.  [Prefer small pull requests](#prefer-small-pull-requests)

## Make atomic commits

When a commit contains unrelated changes, it's harder to read it and to
understand the purpose of each section. An _atomic_
commit makes the smallest change to do one thing.

## Use the commit message to explain the change

Writing good commit messages is important. Not just for yourself, but for other
developers on your project. This includes:

* new (or recently absent) developers who want to get up to speed on progress
* interested external parties who want to follow progress of the project
* people in the public (remember, we code in the open) who want to see our work,
  or learn from our practices
* any future developers (including yourself) who want to see why a change was
  made

### Recommended blog posts on this topic

* [How to Write a Git Commit Message](https://chris.beams.io/posts/git-commit/)
* [5 useful tips for a better commit message](http://robots.thoughtbot.com/5-useful-tips-for-a-better-commit-message)
* [Every line of code is always documented](https://mislav.net/2014/02/hidden-documentation/)

### Content

A good commit message briefly summarises the "what" for scanning purposes, but
also includes the "why". If the "what" in the message isn't enough, the diff is
there as a fallback. This isn't true for the "why" of a change - this can be
much harder or impossible to reconstruct, but is often of great significance.

#### Example

```
Set cache headers
```

prefer:

```
Set cache headers

IE 6 was doing foo, so we need to do X.
See http://example.com/why-is-this-broken for more details.
```

#### Links to issue trackers

A link to a ticket in an issue tracker should not be seen as an alternative to
writing a commit message.

While a link can add some extra context for people reviewing a pull-request,
the commit message should stand on its own.  There's no guarantee that the link
will continue to work in the future when someone is looking through the commit
history to understand why a change was made.

### Structure

Commit messages should start with a one-line summary no longer than 50
characters. Various Git tools (including GitHub) use this as the commit
summary, so you should format it like an email subject, with a leading capital
and no full stop. The Git convention is to write these in the present tense.
For example:

```
Leverage best-of-breed synergies going forward
```

You should leave a blank line before the rest of the commit message, which you
should wrap at around 72 characters: this makes it easier to view commit
messages in a terminal.

#### Example

Taken from [Tim Popeâ€™s guidelines](http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html).

```
Capitalized, short (50 chars or less) summary

More detailed explanatory text, if necessary.  Wrap it to about 72
characters or so.  In some contexts, the first line is treated as the
subject of an email and the rest of the text as the body.  The blank
line separating the summary from the body is critical (unless you omit
the body entirely); tools like rebase can get confused if you run the
two together.

Write your commit message in the present tense: "Fix bug" and not "Fixed
bug."  This convention matches up with commit messages generated by
commands like git merge and git revert.

Further paragraphs come after blank lines.

- Bullet points are okay, too
- Typically a hyphen or asterisk is used for the bullet, preceded by a
  single space, with blank lines in between, but conventions vary here
- Use a hanging indent
```

## Revise history to tell a logical story

Before submitting a pull request for review, check through your branch
history and revise it if necessary. This is the time to break apart
or squash any "wip" commits or those that correct a previous step.

Don't worry about whether your commits accurately reflect the order in which
you originally came to the solution. Use Git's [history rewriting
features](http://git-scm.com/book/en/Git-Tools-Rewriting-History) to arrange
your commits into appropriate logical chunks that will make sense to your
fellow developers. In particular, you may find `git rebase --interactive` very
useful.

When in doubt you should err towards smaller commits, which can be rebased
together later if appropriate. It's harder to break large commits out into
smaller chunks.

The smaller commits should still be logical chunks, but this will give context
for a more specific change and make git tools like `annotate` and `log` more
useful.

## Rebase and merge pull requests

Don't squash a pull request into a single commit, as it undoes all the helpful
work you've done in writing messages for each change.

When the pull request is out of sync with `main` (when GitHub says "This branch
is out-of-date with the base branch"), rebase your commit before merging.

This can be done manually, or via the GitHub interface using the "Update with
rebase" option.

Merge the pull request with a merge commit (the equivalent of `--no-ff)` to
create a history in which all the commits in a pull request are nested
under a merge commit. This groups the commits together to explain the context,
while preserving the information at each step.

## Prefer small pull requests

Separate tasks into separate pull requests as far as possible.
The smaller each pull request, the easier it is to understand, review, and
the less risky it is to deploy.
